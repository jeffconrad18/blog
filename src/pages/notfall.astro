---
import Layout from '@/layouts/Layout.astro'
import themeConfig from '@/config'

// Lade verschlüsselte Daten
import encryptedData from '../../notfall.encrypted.json'

const pageTitle = 'Notfall-Informationen'
const pageDescription = 'Verschlüsselte Notfall-Kontakte und wichtige Informationen'
---

<Layout postTitle={pageTitle} postDescription={pageDescription}>
  <article class="heti">
    <h1 class="post-title">Notfall-Informationen</h1>
    
    <div id="password-section" class="notfall-container">
      <div class="password-box">
        <p class="intro-text">
          Diese Seite enthält verschlüsselte Notfall-Informationen.<br />
          Bitte gib das Passwort ein, um sie zu entschlüsseln.
        </p>
        
        <div class="password-input-wrapper">
          <input
            type="password"
            id="password-input"
            placeholder="Passwort eingeben"
            autocomplete="off"
            class="password-input"
          />
          <button id="decrypt-button" class="btn-primary">
            Entschlüsseln
          </button>
        </div>
        
        <div id="error-message" class="error-message hidden"></div>
        <div id="loading" class="loading hidden">
          <div class="spinner"></div>
          <p>Entschlüssele Daten...</p>
        </div>
      </div>
    </div>
    
    <div id="content-section" class="hidden">
      <div class="success-message">
        Erfolgreich entschlüsselt
      </div>
      <div id="decrypted-content" class="decrypted-content heti"></div>
      <button id="lock-button" class="btn-secondary">
        Wieder verschlüsseln
      </button>
    </div>
  </article>
</Layout>

<style>
  .post-title {
    text-align: center;
    margin-bottom: 2rem;
    color: var(--color-primary);
    /* Größer und fett wie Posts (siehe markdown.css .heti .post-title) */
    font-weight: 700;
  }

  .intro-text {
    text-align: center;
    margin-bottom: 1.5rem;
    color: var(--color-secondary);
    line-height: 1.6;
  }

  .notfall-container {
    padding: 2rem;
    border-radius: 1rem;
    background: var(--color-background);
    border: 1px solid color-mix(in oklch, var(--color-primary) 12%, transparent);
    margin: 2rem 0;
  }

  .password-box {
    max-width: 32rem;
    margin: 0 auto;
  }

  .password-input-wrapper {
    display: flex;
    gap: 0.75rem;
    flex-direction: column;
  }

  @media (min-width: 640px) {
    .password-input-wrapper {
      flex-direction: row;
    }
  }

  .password-input {
    flex: 1;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    border: 1px solid color-mix(in oklch, var(--color-primary) 20%, transparent);
    border-radius: 0.75rem;
    background: var(--color-background);
    color: var(--color-primary);
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    font-family: inherit;
  }

  .password-input:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px var(--color-highlight);
  }

  .password-input::placeholder {
    color: var(--color-secondary);
    opacity: 0.6;
  }

  .btn-primary,
  .btn-secondary {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
    font-weight: 500;
    border: 1px solid var(--color-primary);
    border-radius: 0.75rem;
    background: var(--color-primary);
    color: var(--color-background);
    cursor: pointer;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    white-space: nowrap;
    font-family: inherit;
  }

  .btn-primary:hover,
  .btn-secondary:hover {
    transform: translateY(-1px);
  }

  .btn-primary:active,
  .btn-secondary:active {
    transform: translateY(0);
  }

  .btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .btn-secondary {
    display: block;
    margin: 0 auto;
    background: transparent;
    color: var(--color-primary);
    border-color: color-mix(in oklch, var(--color-primary) 30%, transparent);
  }

  .btn-secondary:hover {
    background: var(--color-primary);
    color: var(--color-background);
    border-color: var(--color-primary);
  }

  .error-message {
    margin-top: 1rem;
    padding: 0.75rem 1rem;
    border-radius: 0.75rem;
    background: oklch(0.65 0.2 29 / 0.1);
    border: 1px solid oklch(0.65 0.2 29 / 0.3);
    color: oklch(0.55 0.2 29);
    text-align: center;
    font-size: 0.95rem;
  }

  .success-message {
    margin-bottom: 1.5rem;
    padding: 0.75rem 1rem;
    border-radius: 0.75rem;
    background: oklch(0.75 0.15 145 / 0.1);
    border: 1px solid oklch(0.75 0.15 145 / 0.3);
    color: oklch(0.55 0.15 145);
    text-align: center;
    font-weight: 500;
  }

  .loading {
    margin-top: 1rem;
    text-align: center;
    color: var(--color-secondary);
  }

  .spinner {
    margin: 0 auto 0.5rem;
    width: 40px;
    height: 40px;
    border: 3px solid color-mix(in oklch, var(--color-primary) 15%, transparent);
    border-top-color: var(--color-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .hidden {
    display: none !important;
  }

  .decrypted-content {
    padding: 2rem;
    border-radius: 1rem;
    background: var(--color-background);
    border: 1px solid color-mix(in oklch, var(--color-primary) 12%, transparent);
    margin-bottom: 1.5rem;
  }

  /* Für Inhalt verwenden wir die siteweiten .heti Markdown-Stile */
</style>

<script is:inline define:vars={{ encryptedData }}>
  // Verschlüsselte Daten aus Astro
  const ENCRYPTED_DATA = encryptedData;

  // DOM-Elemente
  const passwordInput = document.getElementById('password-input');
  const decryptButton = document.getElementById('decrypt-button');
  const lockButton = document.getElementById('lock-button');
  const errorMessage = document.getElementById('error-message');
  const loading = document.getElementById('loading');
  const passwordSection = document.getElementById('password-section');
  const contentSection = document.getElementById('content-section');
  const decryptedContent = document.getElementById('decrypted-content');

  // Robuster, einfacher Markdown-Parser ohne Abhängigkeiten
  function parseMarkdown(md) {
    const escapeHtml = (s) => s
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const formatInline = (s) => {
      // Code inline zuerst, damit innen keine weiteren Umwandlungen passieren
      s = s.replace(/`([^`]+)`/g, (_, code) => `<code>${escapeHtml(code)}</code>`);
      // Links
      s = s.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
      // Fett/Kursiv
      s = s.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
           .replace(/__(.*?)__/g, '<strong>$1</strong>')
           .replace(/\*(.*?)\*/g, '<em>$1</em>')
           .replace(/_(.*?)_/g, '<em>$1</em>');
      return s;
    };

    const lines = md.replace(/\r\n?/g, '\n').split('\n');
    let i = 0; let html = '';
    let inCode = false; let code = [];

    const peek = () => lines[i] || '';
    const isUl = (l) => /^\s*[-*+]\s+/.test(l);
    const isOl = (l) => /^\s*\d+\.\s+/.test(l);
    const isRule = (l) => /^\s*[-*_]{3,}\s*$/.test(l);
    const isHeading = (l) => /^\s{0,3}(#{1,6})\s+(.+)$/.exec(l);
    const isQuote = (l) => /^\s*>\s?/.test(l);

    while (i < lines.length) {
      let line = lines[i];

      // Fenced code block
      if (/^```/.test(line)) {
        if (inCode) {
          html += `<pre><code>${escapeHtml(code.join('\n'))}</code></pre>`;
          code = []; inCode = false; i++; continue;
        } else {
          inCode = true; i++; continue;
        }
      }

      if (inCode) { code.push(line); i++; continue; }

      // Horizontal rule
      if (isRule(line)) { html += '<hr>'; i++; continue; }

      // Heading
      const h = isHeading(line);
      if (h) {
        const level = h[1].length; const text = h[2].trim();
        html += `<h${level}>${formatInline(escapeHtml(text))}</h${level}>`;
        i++; continue;
      }

      // Blockquote
      if (isQuote(line)) {
        const block = [];
        while (i < lines.length && isQuote(lines[i])) {
          block.push(lines[i].replace(/^\s*>\s?/, ''));
          i++;
        }
        html += `<blockquote>${parseMarkdown(block.join('\n'))}</blockquote>`;
        continue;
      }

      // Lists
      if (isUl(line) || isOl(line)) {
        const ordered = isOl(line);
        const items = [];
        while (i < lines.length && (isUl(lines[i]) || isOl(lines[i]))) {
          const itemLine = lines[i].replace(/^\s*(?:[-*+]|\d+\.)\s+/, '');
          // Sammle eventuelle Folgezeilen
          const chunk = [itemLine];
          i++;
          while (i < lines.length && lines[i].trim() !== '' && !isUl(lines[i]) && !isOl(lines[i]) && !isHeading(lines[i]) && !/^```/.test(lines[i])) {
            chunk.push(lines[i]); i++;
          }
          items.push(`<li>${formatInline(escapeHtml(chunk.join(' ')))}</li>`);
          if (i < lines.length && lines[i].trim() === '') i++;
        }
        html += ordered ? `<ol>${items.join('')}</ol>` : `<ul>${items.join('')}</ul>`;
        continue;
      }

      // Blank line
      if (line.trim() === '') { i++; continue; }

      // Paragraph: sammle bis zur nächsten Blockgrenze
      const para = [line];
      i++;
      while (i < lines.length && lines[i].trim() !== '' && !isHeading(lines[i]) && !isUl(lines[i]) && !isOl(lines[i]) && !isRule(lines[i]) && !/^```/.test(lines[i]) && !isQuote(lines[i])) {
        para.push(lines[i]);
        i++;
      }
      html += `<p>${formatInline(escapeHtml(para.join(' ')))}</p>`;
      if (i < lines.length && lines[i].trim() === '') i++;
    }

    return html;
  }

  /**
   * Leitet Schlüssel aus Passwort ab (PBKDF2)
   */
  async function deriveKey(password, salt, iterations) {
    const encoder = new TextEncoder();
    const passwordKey = await crypto.subtle.importKey(
      'raw',
      encoder.encode(password),
      'PBKDF2',
      false,
      ['deriveBits', 'deriveKey']
    );

    return crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: iterations,
        hash: 'SHA-256'
      },
      passwordKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['decrypt']
    );
  }

  /**
   * Base64 zu Uint8Array
   */
  function base64ToUint8Array(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }

  /**
   * Entschlüsselt die Daten mit AES-256-GCM
   */
  async function decryptData(password) {
    try {
      // Dekodiere Base64-Daten
      const salt = base64ToUint8Array(ENCRYPTED_DATA.salt);
      const nonce = base64ToUint8Array(ENCRYPTED_DATA.nonce);
      const ciphertext = base64ToUint8Array(ENCRYPTED_DATA.ciphertext);

      // Leite Schlüssel ab
      const key = await deriveKey(password, salt, ENCRYPTED_DATA.iterations);

      // Entschlüssele
      const decrypted = await crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: nonce
        },
        key,
        ciphertext
      );

      // Konvertiere zu Text
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
    } catch (error) {
      throw new Error('Falsches Passwort oder beschädigte Daten');
    }
  }

  /**
   * Zeigt Fehler an
   */
  function showError(message) {
    errorMessage.textContent = message;
    errorMessage.classList.remove('hidden');
    setTimeout(() => {
      errorMessage.classList.add('hidden');
    }, 5000);
  }

  /**
   * Entschlüsselungs-Handler
   */
  async function handleDecrypt() {
    const password = passwordInput.value;

    if (!password) {
      showError('Bitte gib ein Passwort ein');
      return;
    }

    // Zeige Loading
    loading.classList.remove('hidden');
    errorMessage.classList.add('hidden');
    decryptButton.disabled = true;

    try {
      // Entschlüssele (simuliere etwas Verzögerung für UX)
      await new Promise(resolve => setTimeout(resolve, 300));
      const decrypted = await decryptData(password);

      // Parse Markdown zu HTML
      const htmlContent = parseMarkdown(decrypted);

      // Zeige entschlüsselten Inhalt
      decryptedContent.innerHTML = htmlContent;
      passwordSection.classList.add('hidden');
      contentSection.classList.remove('hidden');

      // Lösche Passwort aus Input
      passwordInput.value = '';
    } catch (error) {
      showError(error.message);
      decryptButton.disabled = false;
    } finally {
      loading.classList.add('hidden');
    }
  }

  /**
   * Verschlüsselungs-Handler (versteckt Inhalt wieder)
   */
  function handleLock() {
    decryptedContent.innerHTML = '';
    contentSection.classList.add('hidden');
    passwordSection.classList.remove('hidden');
    passwordInput.value = '';
    passwordInput.focus();
    decryptButton.disabled = false;
  }

  // Event Listeners
  decryptButton.addEventListener('click', handleDecrypt);
  lockButton.addEventListener('click', handleLock);
  
  passwordInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      handleDecrypt();
    }
  });

  // Fokussiere Input beim Laden
  passwordInput.focus();
</script>
</Layout>
